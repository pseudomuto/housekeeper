package clickhouse

import (
	"context"

	"github.com/ClickHouse/clickhouse-go/v2"
	"github.com/ClickHouse/clickhouse-go/v2/lib/driver"
	"github.com/pkg/errors"
	"github.com/pseudomuto/housekeeper/pkg/parser"
)

type (
	// ClientOptions contains configuration options for the ClickHouse client
	ClientOptions struct {
		// Cluster specifies the cluster name to inject into ON CLUSTER clauses
		// in dumped DDL statements. When set, all extracted DDL will include
		// "ON CLUSTER <cluster_name>" to support distributed ClickHouse deployments.
		Cluster string
	}

	// Client represents a ClickHouse database connection
	Client struct {
		conn    driver.Conn
		options ClientOptions
	}
)

// NewClient creates a new ClickHouse client connection using a DSN.
// The DSN can be in various formats supported by ClickHouse, including:
//   - Simple host:port format: "localhost:9000"
//   - Full DSN: "clickhouse://username:password@host:port/database?param=value"
//   - Native protocol: "tcp://host:port?username=default&password=&database=default"
//
// Example:
//
//	// Simple host:port format
//	client, err := clickhouse.NewClient(ctx, "localhost:9000")
//	if err != nil {
//	    log.Fatal(err)
//	}
//	defer client.Close()
//
//	// Full DSN with authentication and database
//	client, err := clickhouse.NewClient(ctx, "clickhouse://user:pass@localhost:9000/analytics?dial_timeout=10s")
//	if err != nil {
//	    log.Fatal(err)
//	}
//	defer client.Close()
//
//	// Get current schema (databases and dictionaries)
//	sql, err := client.GetSchema(context.Background())
//	if err != nil {
//	    log.Fatal(err)
//	}
//
//	// Print all parsed statements
//	for _, stmt := range sql.Statements {
//	    if stmt.CreateDatabase != nil {
//	        fmt.Printf("Database: %s\n", stmt.CreateDatabase.Name)
//	    }
//	    if stmt.CreateDictionary != nil {
//	        name := stmt.CreateDictionary.Name
//	        if stmt.CreateDictionary.Database != nil {
//	            name = *stmt.CreateDictionary.Database + "." + name
//	        }
//	        fmt.Printf("Dictionary: %s\n", name)
//	    }
//	}
func NewClient(ctx context.Context, dsn string) (*Client, error) {
	return NewClientWithOptions(ctx, dsn, ClientOptions{})
}

// NewClientWithOptions creates a new ClickHouse client connection with custom options.
// This provides additional configuration options beyond the basic DSN connection.
//
// Example:
//
//	// Client with cluster support for distributed deployments
//	client, err := clickhouse.NewClientWithOptions(ctx, "localhost:9000", clickhouse.ClientOptions{
//	    Cluster: "production_cluster",
//	})
//	if err != nil {
//	    log.Fatal(err)
//	}
//	defer client.Close()
//
//	// Dumped schema will include ON CLUSTER clauses
//	schema, err := client.GetSchema(ctx)
//	// All DDL statements will have "ON CLUSTER production_cluster"
func NewClientWithOptions(ctx context.Context, dsn string, clientOpts ClientOptions) (*Client, error) {
	// Try to parse as a full DSN first
	options, err := clickhouse.ParseDSN(dsn)
	if err != nil {
		// If parsing fails, assume it's a simple host:port format
		// and create options manually
		options = &clickhouse.Options{
			Addr: []string{dsn},
		}
	}

	conn, err := clickhouse.Open(options)
	if err != nil {
		return nil, errors.Wrap(err, "failed to open clickhouse connection")
	}

	if err := conn.Ping(ctx); err != nil {
		return nil, errors.Wrap(err, "failed to connect to clickhouse server")
	}

	return &Client{
		conn:    conn,
		options: clientOpts,
	}, nil
}

// Close closes the ClickHouse connection and releases associated resources.
// This method should be called when the client is no longer needed to ensure
// proper cleanup of database connections.
//
// Example:
//
//	client, err := clickhouse.NewClient(ctx, "localhost:9000")
//	if err != nil {
//		log.Fatal(err)
//	}
//	defer client.Close() // Ensure connection is closed
//
// Returns an error if the connection cleanup fails.
func (c *Client) Close() error {
	return c.conn.Close()
}

// ExecuteMigration executes a migration SQL script against the ClickHouse database.
// The SQL can contain multiple DDL statements separated by semicolons, including
// database and dictionary operations such as CREATE, ALTER, DROP, and RENAME.
//
// This method is typically used to apply up/down migration files generated by
// the migration system. All statements are executed within a single connection
// context for consistency.
//
// Example:
//
//	migrationSQL := `
//		CREATE DATABASE analytics ENGINE = Atomic;
//		CREATE DICTIONARY analytics.users (id UInt64) PRIMARY KEY id
//		SOURCE(HTTP(url 'http://api.example.com/users')) LAYOUT(HASHED()) LIFETIME(3600);
//		RENAME DATABASE old_analytics TO analytics_backup;
//	`
//
//	err := client.ExecuteMigration(ctx, migrationSQL)
//	if err != nil {
//		log.Fatalf("Migration failed: %v", err)
//	}
//
// Returns an error if any statement in the migration fails to execute.
func (c *Client) ExecuteMigration(ctx context.Context, sql string) error {
	return c.conn.Exec(ctx, sql)
}

// GetSchema returns complete schema information including databases, tables, views, and dictionaries.
// This is the primary method for retrieving the current ClickHouse schema state,
// including all schema objects, parsed into a structured SQL object.
//
// This method uses dedicated extraction functions for comprehensive schema extraction,
// providing better performance and more complete schema information than the legacy
// database+dictionary-only approach.
//
// System objects are automatically excluded from results.
// All returned DDL statements are validated by the parser before being included.
//
// Example:
//
//	schema, err := client.GetSchema(ctx)
//	if err != nil {
//		log.Fatalf("Failed to get schema: %v", err)
//	}
//
//	// Process all schema objects
//	for _, stmt := range schema.Statements {
//		if stmt.CreateDatabase != nil {
//			fmt.Printf("Database: %s\n", stmt.CreateDatabase.Name)
//		}
//		if stmt.CreateTable != nil {
//			name := stmt.CreateTable.Name
//			if stmt.CreateTable.Database != nil {
//				name = *stmt.CreateTable.Database + "." + name
//			}
//			fmt.Printf("Table: %s\n", name)
//		}
//		if stmt.CreateView != nil {
//			viewType := "VIEW"
//			if stmt.CreateView.Materialized {
//				viewType = "MATERIALIZED VIEW"
//			}
//			name := stmt.CreateView.Name
//			if stmt.CreateView.Database != nil {
//				name = *stmt.CreateView.Database + "." + name
//			}
//			fmt.Printf("%s: %s\n", viewType, name)
//		}
//		if stmt.CreateDictionary != nil {
//			name := stmt.CreateDictionary.Name
//			if stmt.CreateDictionary.Database != nil {
//				name = *stmt.CreateDictionary.Database + "." + name
//			}
//			fmt.Printf("Dictionary: %s\n", name)
//		}
//	}
//
// Returns a parsed SQL containing all schema objects or an error if retrieval fails.
func (c *Client) GetSchema(ctx context.Context) (*parser.SQL, error) {
	return DumpSchema(ctx, c)
}

// GetTables retrieves all table definitions from the ClickHouse instance.
// This method extracts complete CREATE TABLE statements for all non-system tables,
// including column definitions, engine specifications, and table-level settings.
// When the client is configured with a cluster, ON CLUSTER clauses are automatically
// injected into all extracted DDL statements.
//
// The extraction excludes:
//   - System tables and databases
//   - Temporary tables
//   - Internal materialized view tables (.inner.* and .inner_id.*)
//
// Example:
//
//	client, err := clickhouse.NewClientWithOptions(ctx, "localhost:9000", clickhouse.ClientOptions{
//	    Cluster: "production",
//	})
//	if err != nil {
//	    log.Fatal(err)
//	}
//	defer client.Close()
//
//	tables, err := client.GetTables(ctx)
//	if err != nil {
//	    log.Fatal(err)
//	}
//
//	// All table statements will include "ON CLUSTER production"
//	for _, stmt := range tables.Statements {
//	    if stmt.CreateTable != nil {
//	        fmt.Printf("Table: %s\n", stmt.CreateTable.Name)
//	    }
//	}
//
// Returns a *parser.SQL containing validated table CREATE statements or an error if extraction fails.
func (c *Client) GetTables(ctx context.Context) (*parser.SQL, error) {
	return extractTables(ctx, c)
}

// GetViews retrieves all view definitions (both regular and materialized) from the ClickHouse instance.
// This method extracts complete CREATE VIEW and CREATE MATERIALIZED VIEW statements,
// including SELECT queries, engine specifications for materialized views, and population options.
// When the client is configured with a cluster, ON CLUSTER clauses are automatically
// injected into all extracted DDL statements.
//
// The extraction includes:
//   - Regular views (CREATE VIEW statements)
//   - Materialized views (CREATE MATERIALIZED VIEW statements)
//   - Both ENGINE-based and TO table materialized views
//
// Example:
//
//	client, err := clickhouse.NewClient(ctx, "localhost:9000")
//	if err != nil {
//	    log.Fatal(err)
//	}
//	defer client.Close()
//
//	views, err := client.GetViews(ctx)
//	if err != nil {
//	    log.Fatal(err)
//	}
//
//	for _, stmt := range views.Statements {
//	    if stmt.CreateView != nil {
//	        viewType := "VIEW"
//	        if stmt.CreateView.Materialized {
//	            viewType = "MATERIALIZED VIEW"
//	        }
//	        fmt.Printf("%s: %s\n", viewType, stmt.CreateView.Name)
//	    }
//	}
//
// Returns a *parser.SQL containing validated view CREATE statements or an error if extraction fails.
func (c *Client) GetViews(ctx context.Context) (*parser.SQL, error) {
	return extractViews(ctx, c)
}

// GetDictionaries retrieves all dictionary definitions from the ClickHouse instance.
// This method extracts complete CREATE DICTIONARY statements including column definitions,
// source configurations, layout specifications, lifetime settings, and comments.
// When the client is configured with a cluster, ON CLUSTER clauses are automatically
// injected into all extracted DDL statements.
//
// The extraction includes all dictionary features:
//   - Column attributes (IS_OBJECT_ID, HIERARCHICAL, INJECTIVE)
//   - Source configurations (MySQL, HTTP, ClickHouse, File, etc.)
//   - Layout types (FLAT, HASHED, COMPLEX_KEY_HASHED, etc.)
//   - Lifetime configurations (single values or MIN/MAX ranges)
//   - Settings and comments
//
// Returns a *parser.SQL containing validated dictionary CREATE statements or an error if extraction fails.
func (c *Client) GetDictionaries(ctx context.Context) (*parser.SQL, error) {
	return extractDictionaries(ctx, c)
}

// GetDatabases retrieves all database definitions from the ClickHouse instance.
// This method extracts complete CREATE DATABASE statements including engine specifications,
// parameters, and comments. System databases are automatically excluded from the results.
// When the client is configured with a cluster, ON CLUSTER clauses are automatically
// injected into all extracted DDL statements.
//
// Example:
//
//	databases, err := client.GetDatabases(ctx)
//	if err != nil {
//	    log.Fatal(err)
//	}
//
//	for _, stmt := range databases.Statements {
//	    if stmt.CreateDatabase != nil {
//	        fmt.Printf("Database: %s", stmt.CreateDatabase.Name)
//	        if stmt.CreateDatabase.Engine != nil {
//	            fmt.Printf(" (Engine: %s)", stmt.CreateDatabase.Engine.Name)
//	        }
//	        fmt.Println()
//	    }
//	}
//
// Returns a *parser.SQL containing validated database CREATE statements or an error if extraction fails.
func (c *Client) GetDatabases(ctx context.Context) (*parser.SQL, error) {
	return extractDatabases(ctx, c)
}

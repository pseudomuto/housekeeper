package clickhouse

import (
	"context"

	"github.com/ClickHouse/clickhouse-go/v2"
	"github.com/ClickHouse/clickhouse-go/v2/lib/driver"
	"github.com/pseudomuto/housekeeper/pkg/parser"
)

type (
	// Client represents a ClickHouse database connection
	Client struct {
		conn driver.Conn
	}
)

// NewClient creates a new ClickHouse client connection.
// The DSN should be in the format "host:port" (e.g., "localhost:9000").
//
// Example:
//
//	client, err := clickhouse.NewClient("localhost:9000")
//	if err != nil {
//	    log.Fatal(err)
//	}
//	defer client.Close()
//
//	// Get current schema (databases and dictionaries)
//	grammar, err := client.GetSchema(context.Background())
//	if err != nil {
//	    log.Fatal(err)
//	}
//
//	// Print all parsed statements
//	for _, stmt := range grammar.Statements {
//	    if stmt.CreateDatabase != nil {
//	        fmt.Printf("Database: %s\n", stmt.CreateDatabase.Name)
//	    }
//	    if stmt.CreateDictionary != nil {
//	        name := stmt.CreateDictionary.Name
//	        if stmt.CreateDictionary.Database != nil {
//	            name = *stmt.CreateDictionary.Database + "." + name
//	        }
//	        fmt.Printf("Dictionary: %s\n", name)
//	    }
//	}
func NewClient(ctx context.Context, dsn string) (*Client, error) {
	conn, err := clickhouse.Open(&clickhouse.Options{
		Addr: []string{dsn},
	})
	if err != nil {
		return nil, err
	}

	if err := conn.Ping(ctx); err != nil {
		return nil, err
	}

	return &Client{conn: conn}, nil
}

// Close closes the ClickHouse connection and releases associated resources.
// This method should be called when the client is no longer needed to ensure
// proper cleanup of database connections.
//
// Example:
//
//	client, err := clickhouse.NewClient("localhost:9000")
//	if err != nil {
//		log.Fatal(err)
//	}
//	defer client.Close() // Ensure connection is closed
//
// Returns an error if the connection cleanup fails.
func (c *Client) Close() error {
	return c.conn.Close()
}

// ExecuteMigration executes a migration SQL script against the ClickHouse database.
// The SQL can contain multiple DDL statements separated by semicolons, including
// database and dictionary operations such as CREATE, ALTER, DROP, and RENAME.
//
// This method is typically used to apply up/down migration files generated by
// the migration system. All statements are executed within a single connection
// context for consistency.
//
// Example:
//
//	migrationSQL := `
//		CREATE DATABASE analytics ENGINE = Atomic;
//		CREATE DICTIONARY analytics.users (id UInt64) PRIMARY KEY id
//		SOURCE(HTTP(url 'http://api.example.com/users')) LAYOUT(HASHED()) LIFETIME(3600);
//		RENAME DATABASE old_analytics TO analytics_backup;
//	`
//
//	err := client.ExecuteMigration(ctx, migrationSQL)
//	if err != nil {
//		log.Fatalf("Migration failed: %v", err)
//	}
//
// Returns an error if any statement in the migration fails to execute.
func (c *Client) ExecuteMigration(ctx context.Context, sql string) error {
	return c.conn.Exec(ctx, sql)
}

// GetSchema returns complete schema information including databases, tables, views, and dictionaries.
// This is the primary method for retrieving the current ClickHouse schema state,
// including all schema objects, parsed into a structured SQL object.
//
// This method uses dedicated extraction functions for comprehensive schema extraction,
// providing better performance and more complete schema information than the legacy
// database+dictionary-only approach.
//
// System objects are automatically excluded from results.
// All returned DDL statements are validated by the parser before being included.
//
// Example:
//
//	schema, err := client.GetSchema(ctx)
//	if err != nil {
//		log.Fatalf("Failed to get schema: %v", err)
//	}
//
//	// Process all schema objects
//	for _, stmt := range schema.Statements {
//		if stmt.CreateDatabase != nil {
//			fmt.Printf("Database: %s\n", stmt.CreateDatabase.Name)
//		}
//		if stmt.CreateTable != nil {
//			name := stmt.CreateTable.Name
//			if stmt.CreateTable.Database != nil {
//				name = *stmt.CreateTable.Database + "." + name
//			}
//			fmt.Printf("Table: %s\n", name)
//		}
//		if stmt.CreateView != nil {
//			viewType := "VIEW"
//			if stmt.CreateView.Materialized {
//				viewType = "MATERIALIZED VIEW"
//			}
//			name := stmt.CreateView.Name
//			if stmt.CreateView.Database != nil {
//				name = *stmt.CreateView.Database + "." + name
//			}
//			fmt.Printf("%s: %s\n", viewType, name)
//		}
//		if stmt.CreateDictionary != nil {
//			name := stmt.CreateDictionary.Name
//			if stmt.CreateDictionary.Database != nil {
//				name = *stmt.CreateDictionary.Database + "." + name
//			}
//			fmt.Printf("Dictionary: %s\n", name)
//		}
//	}
//
// Returns a parsed SQL containing all schema objects or an error if retrieval fails.
func (c *Client) GetSchema(ctx context.Context) (*parser.SQL, error) {
	return DumpSchema(ctx, c)
}

// GetTables retrieves all table definitions from the ClickHouse instance.
//
// Returns a *parser.SQL containing table CREATE statements.
func (c *Client) GetTables(ctx context.Context) (*parser.SQL, error) {
	return extractTables(ctx, c)
}

// GetViews retrieves all view definitions (both regular and materialized) from the ClickHouse instance.
//
// Returns a *parser.SQL containing view CREATE statements.
func (c *Client) GetViews(ctx context.Context) (*parser.SQL, error) {
	return extractViews(ctx, c)
}

// GetDictionaries retrieves all dictionary definitions from the ClickHouse instance.
//
// Returns a *parser.SQL containing dictionary CREATE statements.
func (c *Client) GetDictionaries(ctx context.Context) (*parser.SQL, error) {
	return extractDictionaries(ctx, c)
}

// GetDatabases retrieves all database definitions from the ClickHouse instance.
//
// Returns a *parser.SQL containing database CREATE statements.
func (c *Client) GetDatabases(ctx context.Context) (*parser.SQL, error) {
	return extractDatabases(ctx, c)
}
